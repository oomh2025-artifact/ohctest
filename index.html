<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ å£è¿°è©¦é¨“å¯¾ç­–</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .markdown-input { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚­ãƒ¼
    const STORAGE_KEY = 'ohc-exam-review-items';
    const API_KEY_STORAGE = 'ohc-exam-api-key';
    const CUSTOM_QUESTIONS_KEY = 'ohc-exam-custom-questions';

    // æ¡ç‚¹ç”¨ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    const GRADING_SYSTEM_PROMPT = `ã‚ãªãŸã¯åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆå£è¿°è©¦é¨“ã®æ¡ç‚¹è€…ã§ã™ã€‚

ã€è©¦é¨“å®˜ã®4ã¤ã®è©•ä¾¡è»¸ã€‘
â‘ çŸ¥è­˜ã®æ·±ã•ï¼šæš—è¨˜ã§ã¯ãªãç†è§£ã—ã¦ã„ã‚‹ã‹ã€‚èƒŒæ™¯ãƒ»ç†ç”±ã‚’èª¬æ˜ã§ãã‚‹ã‹ã€‚
â‘¡å®Ÿå‹™ã§ã®å¯¾å¿œåŠ›ï¼šç¾å ´ã§ã‚³ãƒ³ã‚µãƒ«ãƒ†ã‚£ãƒ³ã‚°ã§ãã‚‹ã‹ã€‚ç¾å®Ÿçš„åˆ¶ç´„ã¸ã®é…æ…®ãŒã‚ã‚‹ã‹ã€‚
â‘¢åˆ¤æ–­ã®èª å®Ÿã•ï¼šã‚ã‹ã‚‰ãªã„ã“ã¨ã‚’æ­£ç›´ã«è¨€ãˆã‚‹ã‹ã€‚çŸ¥ã£ãŸã‹ã¶ã‚Šã‚’ã—ãªã„ã‹ã€‚
â‘£æ€è€ƒã®æŸ”è»Ÿæ€§ï¼šæƒ³å®šå¤–ã®è³ªå•ã«ã‚‚å¯¾å¿œã§ãã‚‹ã‹ã€‚è¤‡æ•°ã®å¯èƒ½æ€§ã‚’è€ƒãˆã‚‰ã‚Œã‚‹ã‹ã€‚

ã€åŠ ç‚¹ãƒã‚¤ãƒ³ãƒˆã€‘
ãƒ»3ç®¡ç†ï¼ˆä½œæ¥­ç’°å¢ƒç®¡ç†ãƒ»ä½œæ¥­ç®¡ç†ãƒ»å¥åº·ç®¡ç†ï¼‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ã£ãŸæ•´ç†
ãƒ»å…·ä½“çš„ãªæ•°å€¤ãƒ»åŸºæº–ã®æç¤º
ãƒ»æœ€æ–°ã®åˆ¶åº¦ãƒ»æ”¹æ­£ã¸ã®è¨€åŠ
ãƒ»è¤‡æ•°ã®å¯èƒ½æ€§ã®åˆ—æŒ™
ãƒ»å°è¦æ¨¡ä¼æ¥­ãƒ»ç¾å®Ÿçš„åˆ¶ç´„ã¸ã®é…æ…®

ã€æ¸›ç‚¹ãƒã‚¤ãƒ³ãƒˆã€‘
ãƒ»ã€Œæ€ã„ã¾ã™ã€ã®å¤šç”¨ï¼ˆæ–­å®šã™ã¹ãå ´é¢ã§æ›–æ˜§ï¼‰
ãƒ»èã‹ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç­”ãˆã¦é–“é•ãˆã‚‹
ãƒ»ã€Œä¸€èˆ¬çš„ã«ã¯ã€ã§é€ƒã’ã¦å…·ä½“æ€§ãŒãªã„
ãƒ»ã€Œå®‰å…¨ã§ã™ã€ã¨ä¸ç”¨æ„ã«æ–­è¨€

10ç‚¹æº€ç‚¹ã§æ¡ç‚¹ã—ã¦ãã ã•ã„ã€‚
ã€æ¡ç‚¹åŸºæº–ã€‘
10ç‚¹:å®Œç’§ï¼ˆå…¨ã¦ã®è©•ä¾¡è»¸ã§å„ªã‚Œã¦ã„ã‚‹ï¼‰
8-9ç‚¹:å„ªç§€ï¼ˆä¸»è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’ç¶²ç¾…ï¼‰
6-7ç‚¹:åˆæ ¼ï¼ˆå¿…é ˆè¦ç´ ã‚’å«ã¿ã€å¤§ããªèª¤ã‚Šãªã—ï¼‰
4-5ç‚¹:ä¸€éƒ¨æ­£è§£ï¼ˆé‡è¦ãªè¦ç´ ãŒæ¬ ã‘ã¦ã„ã‚‹ï¼‰
2-3ç‚¹:æ–¹å‘æ€§ã®ã¿ï¼ˆç†è§£ãŒè¡¨é¢çš„ï¼‰
0-1ç‚¹:çš„å¤–ã‚Œ

å¿…ãšä»¥ä¸‹ã®å½¢å¼ã§å›ç­”ï¼š
ç‚¹æ•°: [0-10]
è¬›è©•: [å…·ä½“çš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã€100å­—ä»¥å†…]`;

    // ã‚µãƒ³ãƒ—ãƒ«Markdownãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    const SAMPLE_MARKDOWN = `## ãƒ†ãƒ¼ãƒXï¼šæ–°ã—ã„ãƒ†ãƒ¼ãƒå

---

### ã€äºˆæƒ³å•é¡Œ XXã€‘Q1ï¼ˆåŸºæœ¬å•é¡Œï¼‰
**ã“ã“ã«è³ªå•æ–‡ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚**

### ã€æ¨¡ç¯„è§£ç­”ã€‘
ã“ã“ã«æ¨¡ç¯„è§£ç­”ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

### ã€ã“ã®å•é¡Œã§è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆã€‘
- è©•ä¾¡ãƒã‚¤ãƒ³ãƒˆ1
- è©•ä¾¡ãƒã‚¤ãƒ³ãƒˆ2

### ã€æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•ã¨å›ç­”ã€‘

**Qï¼šè¿½åŠ è³ªå•1**

**Aï¼š** è¿½åŠ è³ªå•1ã¸ã®å›ç­”

---

### ã€äºˆæƒ³å•é¡Œ XXã€‘Q2ï¼ˆè©³ç´°å•é¡Œï¼‰
**ã“ã“ã«è©³ç´°å•é¡Œã®è³ªå•æ–‡ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚**

### ã€æ¨¡ç¯„è§£ç­”ã€‘
ã“ã“ã«æ¨¡ç¯„è§£ç­”ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

### ã€ã“ã®å•é¡Œã§è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆã€‘
- è©•ä¾¡ãƒã‚¤ãƒ³ãƒˆ1
- è©•ä¾¡ãƒã‚¤ãƒ³ãƒˆ2

### ã€æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•ã¨å›ç­”ã€‘

**Qï¼šè¿½åŠ è³ªå•1**

**Aï¼š** è¿½åŠ è³ªå•1ã¸ã®å›ç­”`;

    // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆæœ¬ç·¨ç”¨ï¼‰
    const parseMainQuestionsMarkdown = (markdown) => {
      const themes = [];
      let currentTheme = null;
      let currentQuestion = null;
      let currentSection = null;
      let currentFollowUp = null;
      
      const lines = markdown.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        const themeMatch = line.match(/^##\s*ãƒ†ãƒ¼ãƒ\d*[ï¼š:]?\s*(.+?)$/);
        if (themeMatch) {
          if (currentTheme && currentTheme.questions.length > 0) {
            themes.push(currentTheme);
          }
          currentTheme = { id: themes.length + 1, name: themeMatch[1].trim(), questions: [] };
          currentQuestion = null;
          currentSection = null;
          continue;
        }
        
        const questionMatch = line.match(/###\s*ã€äºˆæƒ³å•é¡Œ\s*\d+ã€‘\s*Q?(\d+)?[ï¼ˆ(]?(åŸºæœ¬|è©³ç´°|å¿œç”¨)?å•é¡Œ?[ï¼‰)]?/i) ||
                             line.match(/\*\*Q\d+[ï¼ˆ(](åŸºæœ¬|è©³ç´°|å¿œç”¨)å•é¡Œ[ï¼‰)][ï¼š:]\*\*/);
        if (questionMatch && currentTheme) {
          if (currentQuestion) currentTheme.questions.push(currentQuestion);
          const level = questionMatch[2] || questionMatch[1] || 'åŸºæœ¬';
          currentQuestion = { 
            level: level, 
            question: '', 
            modelAnswer: '', 
            keyPoints: [], 
            followUpQA: [],
            followUpQuestions: []
          };
          currentSection = 'question';
          continue;
        }
        
        if (currentSection === 'question' && line.startsWith('**') && !line.includes('ã€')) {
          const questionText = line.replace(/^\*\*/, '').replace(/\*\*$/, '').trim();
          if (questionText && !questionText.includes('Qï¼š') && !questionText.includes('Aï¼š')) {
            currentQuestion.question = questionText;
          }
          continue;
        }
        
        if (line.includes('ã€æ¨¡ç¯„è§£ç­”ã€‘') || line.includes('### ã€æ¨¡ç¯„è§£ç­”ã€‘')) { 
          currentSection = 'modelAnswer'; 
          continue; 
        }
        if (line.includes('è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆ')) { 
          currentSection = 'keyPoints'; 
          continue; 
        }
        if (line.includes('æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•ã¨å›ç­”')) { 
          currentSection = 'followUpQA'; 
          continue; 
        }
        if (line.includes('æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•')) { 
          currentSection = 'followUp'; 
          continue; 
        }
        
        if (currentSection === 'followUpQA' && currentQuestion) {
          const followUpQ = line.match(/^\*\*Q[ï¼š:]\s*(.+?)\*\*$/);
          if (followUpQ) {
            if (currentFollowUp && currentFollowUp.answer) {
              currentQuestion.followUpQA.push(currentFollowUp);
              currentQuestion.followUpQuestions.push(currentFollowUp.question);
            }
            currentFollowUp = { question: followUpQ[1].trim(), answer: '' };
            continue;
          }
          const followUpA = line.match(/^\*\*A[ï¼š:]\*\*\s*(.*)$/);
          if (followUpA && currentFollowUp) {
            currentFollowUp.answer = followUpA[1].trim();
            continue;
          }
          if (currentFollowUp && !line.startsWith('**') && !line.startsWith('#') && !line.startsWith('---') && line.trim()) {
            currentFollowUp.answer += ' ' + line.trim();
          }
        }
        
        if (line.trim() === '---') {
          if (currentFollowUp && currentQuestion && currentFollowUp.answer) {
            currentQuestion.followUpQA.push(currentFollowUp);
            currentQuestion.followUpQuestions.push(currentFollowUp.question);
            currentFollowUp = null;
          }
          continue;
        }
        
        if (currentQuestion && currentSection) {
          const cleanLine = line.trim();
          if (!cleanLine) continue;
          
          if (currentSection === 'modelAnswer' && !cleanLine.startsWith('**') && !cleanLine.startsWith('#') && !cleanLine.startsWith('---')) {
            currentQuestion.modelAnswer += (currentQuestion.modelAnswer ? '\n' : '') + cleanLine;
          } else if (currentSection === 'keyPoints' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            currentQuestion.keyPoints.push(cleanLine.replace(/^[-ãƒ»]\s*/, ''));
          } else if (currentSection === 'followUp' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            const q = cleanLine.replace(/^[-ãƒ»]\s*/, '').replace(/[ã€Œã€]/g, '');
            currentQuestion.followUpQuestions.push(q);
          }
        }
      }
      
      if (currentFollowUp && currentQuestion && currentFollowUp.answer) {
        currentQuestion.followUpQA.push(currentFollowUp);
        currentQuestion.followUpQuestions.push(currentFollowUp.question);
      }
      if (currentQuestion && currentTheme) currentTheme.questions.push(currentQuestion);
      if (currentTheme && currentTheme.questions.length > 0) themes.push(currentTheme);
      
      return themes;
    };

    // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆè¿½åŠ å•é¡Œç”¨ï¼‰
    const parseExtraQuestionsMarkdown = (markdown) => {
      const themes = [];
      let currentTheme = null;
      let currentQuestion = null;
      let currentSection = null;
      let currentFollowUp = null;
      
      const lines = markdown.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        const themeMatch = line.match(/^##\s*ãƒ†ãƒ¼ãƒ\d*[ï¼š:]?\s*(.+?)$/);
        if (themeMatch) {
          if (currentTheme && currentTheme.questions.length > 0) {
            themes.push(currentTheme);
          }
          currentTheme = { id: themes.length + 1, name: themeMatch[1].trim(), questions: [] };
          currentQuestion = null;
          continue;
        }
        
        const questionMatch = line.match(/###\s*ã€è¿½åŠ å•é¡Œ\s*\d+ã€‘/);
        if (questionMatch && currentTheme) {
          if (currentQuestion) currentTheme.questions.push(currentQuestion);
          currentQuestion = { 
            level: 'è¿½åŠ ', 
            question: '', 
            modelAnswer: '', 
            keyPoints: [], 
            followUpQA: [],
            followUpQuestions: []
          };
          currentSection = 'question';
          continue;
        }
        
        if (currentSection === 'question' && line.startsWith('**') && !line.includes('ã€')) {
          const questionText = line.replace(/^\*\*/, '').replace(/\*\*$/, '').trim();
          if (questionText && !questionText.includes('Qï¼š') && !questionText.includes('Aï¼š')) {
            currentQuestion.question = questionText;
          }
          continue;
        }
        
        if (line.includes('ã€æ¨¡ç¯„è§£ç­”ã€‘')) { currentSection = 'modelAnswer'; continue; }
        if (line.includes('è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆ')) { currentSection = 'keyPoints'; continue; }
        if (line.includes('æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•ã¨å›ç­”')) { currentSection = 'followUpQA'; continue; }
        if (line.includes('æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•')) { currentSection = 'followUp'; continue; }
        
        if (currentSection === 'followUpQA' && currentQuestion) {
          const followUpQ = line.match(/^\*\*Q[ï¼š:]\s*(.+?)\*\*$/);
          if (followUpQ) {
            if (currentFollowUp && currentFollowUp.answer) {
              currentQuestion.followUpQA.push(currentFollowUp);
              currentQuestion.followUpQuestions.push(currentFollowUp.question);
            }
            currentFollowUp = { question: followUpQ[1].trim(), answer: '' };
            continue;
          }
          const followUpA = line.match(/^\*\*A[ï¼š:]\*\*\s*(.*)$/);
          if (followUpA && currentFollowUp) {
            currentFollowUp.answer = followUpA[1].trim();
            continue;
          }
          if (currentFollowUp && !line.startsWith('**') && !line.startsWith('#') && !line.startsWith('---') && line.trim()) {
            currentFollowUp.answer += ' ' + line.trim();
          }
        }
        
        if (line.trim() === '---') {
          if (currentFollowUp && currentQuestion && currentFollowUp.answer) {
            currentQuestion.followUpQA.push(currentFollowUp);
            currentQuestion.followUpQuestions.push(currentFollowUp.question);
            currentFollowUp = null;
          }
          continue;
        }
        
        if (currentQuestion && currentSection) {
          const cleanLine = line.trim();
          if (!cleanLine) continue;
          
          if (currentSection === 'modelAnswer' && !cleanLine.startsWith('**') && !cleanLine.startsWith('#')) {
            currentQuestion.modelAnswer += (currentQuestion.modelAnswer ? '\n' : '') + cleanLine;
          } else if (currentSection === 'keyPoints' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            currentQuestion.keyPoints.push(cleanLine.replace(/^[-ãƒ»]\s*/, ''));
          } else if (currentSection === 'followUp' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            currentQuestion.followUpQuestions.push(cleanLine.replace(/^[-ãƒ»]\s*/, '').replace(/[ã€Œã€]/g, ''));
          }
        }
      }
      
      if (currentFollowUp && currentQuestion && currentFollowUp.answer) {
        currentQuestion.followUpQA.push(currentFollowUp);
        currentQuestion.followUpQuestions.push(currentFollowUp.question);
      }
      if (currentQuestion && currentTheme) currentTheme.questions.push(currentQuestion);
      if (currentTheme && currentTheme.questions.length > 0) themes.push(currentTheme);
      
      return themes;
    };

    // è¿½åŠ è³ªå•å›ç­”é›†ãƒ‘ãƒ¼ã‚µãƒ¼
    const parseFollowUpMarkdown = (markdown) => {
      const followUps = {};
      let currentQuestion = null;
      let currentAnswer = '';
      
      const lines = markdown.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        const questionMatch = line.match(/^###\s*Q[ï¼š:]\s*(.+)$/);
        if (questionMatch) {
          if (currentQuestion && currentAnswer) followUps[currentQuestion] = currentAnswer.trim();
          currentQuestion = questionMatch[1].trim();
          currentAnswer = '';
          continue;
        }
        
        const answerMatch = line.match(/^\*\*A[ï¼š:]\*\*\s*(.*)$/);
        if (answerMatch) { currentAnswer = answerMatch[1]; continue; }
        if (line.trim() === '---' || line.startsWith('## ') || line.trim() === '') continue;
        if (currentQuestion && !line.startsWith('#') && !line.startsWith('**')) {
          currentAnswer += ' ' + line.trim();
        }
      }
      
      if (currentQuestion && currentAnswer) followUps[currentQuestion] = currentAnswer.trim();
      return followUps;
    };

    function App() {
      const [appMode, setAppMode] = useState('loading');
      const [examType, setExamType] = useState('main');
      const [mainThemes, setMainThemes] = useState([]);
      const [extraThemes, setExtraThemes] = useState([]);
      const [customThemes, setCustomThemes] = useState([]);
      const [followUpAnswers, setFollowUpAnswers] = useState({});
      const [reviewItems, setReviewItems] = useState([]);
      const [loadError, setLoadError] = useState(null);
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyInput, setShowApiKeyInput] = useState(false);
      
      // å•é¡Œè¿½åŠ ç”»é¢ç”¨
      const [markdownInput, setMarkdownInput] = useState('');
      const [parseResult, setParseResult] = useState(null);
      const [parseError, setParseError] = useState(null);
      const [addMode, setAddMode] = useState('markdown'); // 'markdown' or 'json'
      const [jsonInput, setJsonInput] = useState('');
      
      // è©¦é¨“ç”»é¢ç”¨
      const [gameState, setGameState] = useState('start');
      const [messages, setMessages] = useState([]);
      const [inputValue, setInputValue] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [currentThemeIndex, setCurrentThemeIndex] = useState(0);
      const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
      const [completedThemes, setCompletedThemes] = useState([]);
      const [scores, setScores] = useState([]);
      const [usedThemes, setUsedThemes] = useState([]);
      const [takeHomeCount, setTakeHomeCount] = useState(0);
      const [takeHomeThemes, setTakeHomeThemes] = useState([]);
      const [currentReviewIndex, setCurrentReviewIndex] = useState(0);
      const [waitingForFollowUp, setWaitingForFollowUp] = useState(false);
      const [currentFollowUp, setCurrentFollowUp] = useState(null);
      const MAX_TAKE_HOME = 2;
      
      const messagesEndRef = useRef(null);

      // ç¾åœ¨ã®ãƒ†ãƒ¼ãƒãƒªã‚¹ãƒˆ
      const getThemes = () => {
        if (examType === 'main') return mainThemes;
        if (examType === 'extra') return extraThemes;
        if (examType === 'custom') return customThemes;
        return [];
      };
      const themes = getThemes();

      // åˆæœŸåŒ–
      useEffect(() => {
        const loadData = async () => {
          try {
            const savedReview = localStorage.getItem(STORAGE_KEY);
            if (savedReview) setReviewItems(JSON.parse(savedReview));
            
            const savedApiKey = localStorage.getItem(API_KEY_STORAGE);
            if (savedApiKey) setApiKey(savedApiKey);
            
            const savedCustom = localStorage.getItem(CUSTOM_QUESTIONS_KEY);
            if (savedCustom) setCustomThemes(JSON.parse(savedCustom));
            
            // æœ¬ç·¨èª­ã¿è¾¼ã¿
            const mainRes = await fetch('./data/questions_main.md').catch(() => null);
            if (mainRes && mainRes.ok) {
              const text = await mainRes.text();
              const parsed = parseMainQuestionsMarkdown(text);
              if (parsed.length > 0) setMainThemes(parsed);
            }
            
            // è¿½åŠ å•é¡Œèª­ã¿è¾¼ã¿
            const extraRes = await fetch('./data/questions_extra.md').catch(() => null);
            if (extraRes && extraRes.ok) {
              const text = await extraRes.text();
              const parsed = parseExtraQuestionsMarkdown(text);
              if (parsed.length > 0) setExtraThemes(parsed);
            }
            
            // è¿½åŠ è³ªå•å›ç­”é›†èª­ã¿è¾¼ã¿
            const followUpRes = await fetch('./data/followup.md').catch(() => null);
            if (followUpRes && followUpRes.ok) {
              const text = await followUpRes.text();
              const parsed = parseFollowUpMarkdown(text);
              if (Object.keys(parsed).length > 0) setFollowUpAnswers(parsed);
            }
            
            setAppMode('menu');
          } catch (err) {
            console.error('Load error:', err);
            setLoadError(err.message);
            setAppMode('menu');
          }
        };
        loadData();
      }, []);

      useEffect(() => {
        if (appMode !== 'loading') {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(reviewItems));
        }
      }, [reviewItems, appMode]);

      useEffect(() => {
        localStorage.setItem(CUSTOM_QUESTIONS_KEY, JSON.stringify(customThemes));
      }, [customThemes]);

      const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      useEffect(() => { scrollToBottom(); }, [messages]);

      const addMessage = (role, content) => setMessages(prev => [...prev, { role, content }]);

      const saveApiKey = (key) => {
        setApiKey(key);
        localStorage.setItem(API_KEY_STORAGE, key);
      };

      // Markdownã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
      const handleParseMarkdown = () => {
        try {
          const parsed = parseMainQuestionsMarkdown(markdownInput);
          if (parsed.length === 0) {
            setParseError('å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            setParseResult(null);
          } else {
            setParseResult(parsed);
            setParseError(null);
          }
        } catch (err) {
          setParseError('ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ' + err.message);
          setParseResult(null);
        }
      };

      // ãƒ‘ãƒ¼ã‚¹ã—ãŸå•é¡Œã‚’ä¿å­˜
      const handleSaveQuestions = () => {
        if (!parseResult || parseResult.length === 0) return;
        
        const newThemes = parseResult.map((theme, idx) => ({
          ...theme,
          id: Date.now() + idx,
          isCustom: true
        }));
        
        setCustomThemes(prev => [...prev, ...newThemes]);
        setMarkdownInput('');
        setParseResult(null);
        setAppMode('menu');
      };

      // JSONã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
      const handleImportJson = () => {
        try {
          const parsed = JSON.parse(jsonInput);
          if (!Array.isArray(parsed)) {
            setParseError('JSONã¯é…åˆ—å½¢å¼ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚');
            return;
          }
          
          const validThemes = parsed.filter(t => t.name && t.questions && t.questions.length > 0);
          if (validThemes.length === 0) {
            setParseError('æœ‰åŠ¹ãªãƒ†ãƒ¼ãƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
            return;
          }
          
          const newThemes = validThemes.map((theme, idx) => ({
            ...theme,
            id: Date.now() + idx,
            isCustom: true
          }));
          
          setCustomThemes(prev => [...prev, ...newThemes]);
          setJsonInput('');
          setParseError(null);
          setAppMode('menu');
        } catch (err) {
          setParseError('JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ' + err.message);
        }
      };

      // JSONã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
      const handleExportJson = () => {
        if (!parseResult) return;
        const json = JSON.stringify(parseResult, null, 2);
        navigator.clipboard.writeText(json);
        alert('JSONã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
      };

      // ã‚«ã‚¹ã‚¿ãƒ å•é¡Œã‚’å‰Šé™¤
      const handleDeleteCustomTheme = (themeId) => {
        if (confirm('ã“ã®ãƒ†ãƒ¼ãƒã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
          setCustomThemes(prev => prev.filter(t => t.id !== themeId));
        }
      };

      // æ¡ç‚¹API
      const gradeAnswer = async (question, modelAnswer, keyPoints, userAnswer) => {
        if (!apiKey) {
          return { score: 5, feedback: 'âš ï¸ APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰è¨­å®šã—ã¦ãã ã•ã„ã€‚' };
        }
        try {
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              "x-api-key": apiKey,
              "anthropic-version": "2023-06-01",
              "anthropic-dangerous-direct-browser-access": "true"
            },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 1000,
              system: GRADING_SYSTEM_PROMPT,
              messages: [{
                role: "user",
                content: `ã€å•é¡Œã€‘${question}\nã€æ¨¡ç¯„è§£ç­”ã€‘${modelAnswer}\nã€è©•ä¾¡ãƒã‚¤ãƒ³ãƒˆã€‘${keyPoints.join(', ')}\nã€å—é¨“è€…ã®å›ç­”ã€‘${userAnswer}\n\næ¡ç‚¹ã—ã¦ãã ã•ã„ã€‚`
              }]
            })
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              return { score: 5, feedback: 'âš ï¸ APIã‚­ãƒ¼ãŒç„¡åŠ¹ã§ã™ã€‚æ­£ã—ã„ã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚' };
            }
            return { score: 5, feedback: `âš ï¸ APIã‚¨ãƒ©ãƒ¼ (${response.status})` };
          }
          
          const data = await response.json();
          const text = data.content[0].text;
          const scoreMatch = text.match(/ç‚¹æ•°[:ï¼š]\s*(\d+)/);
          const feedbackMatch = text.match(/è¬›è©•[:ï¼š]\s*(.+)/s);
          return {
            score: scoreMatch ? parseInt(scoreMatch[1]) : 5,
            feedback: feedbackMatch ? feedbackMatch[1].trim() : text
          };
        } catch (error) {
          console.error('Grading error:', error);
          return { score: 5, feedback: 'âš ï¸ æ¡ç‚¹ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚' };
        }
      };

      const addToReview = (item) => {
        const newItem = { ...item, id: Date.now(), addedAt: new Date().toISOString() };
        setReviewItems(prev => [...prev, newItem]);
      };

      const removeFromReview = (id) => {
        setReviewItems(prev => prev.filter(item => item.id !== id));
      };

      const selectNextTheme = () => {
        const currentThemes = getThemes();
        const availableThemes = currentThemes.filter((_, idx) => !usedThemes.includes(idx));
        if (availableThemes.length === 0) return null;
        const randomIndex = Math.floor(Math.random() * availableThemes.length);
        const theme = availableThemes[randomIndex];
        const originalIndex = currentThemes.findIndex(t => t.id === theme.id);
        setUsedThemes(prev => [...prev, originalIndex]);
        setCurrentThemeIndex(originalIndex);
        setCurrentQuestionIndex(0);
        return theme;
      };

      const getCurrentQuestion = () => {
        const currentThemes = getThemes();
        const theme = currentThemes[currentThemeIndex];
        if (!theme) return null;
        return theme.questions[currentQuestionIndex];
      };

      const startExam = (type) => {
        setExamType(type);
        setAppMode('exam');
        setGameState('start');
        setMessages([]);
        setCurrentThemeIndex(0);
        setCurrentQuestionIndex(0);
        setCompletedThemes([]);
        setScores([]);
        setUsedThemes([]);
        setTakeHomeCount(0);
        setTakeHomeThemes([]);
        setWaitingForFollowUp(false);
        setCurrentFollowUp(null);
        
        let targetThemes;
        let typeName;
        if (type === 'main') {
          targetThemes = mainThemes;
          typeName = 'æœ¬ç·¨ï¼ˆè©³ç´°è§£èª¬ä»˜ãï¼‰';
        } else if (type === 'extra') {
          targetThemes = extraThemes;
          typeName = 'è¿½åŠ å•é¡Œç·¨';
        } else {
          targetThemes = customThemes;
          typeName = 'ã‚«ã‚¹ã‚¿ãƒ å•é¡Œ';
        }
        
        const maxThemes = Math.min(5, targetThemes.length);
        
        setTimeout(() => {
          setMessages([{
            role: 'examiner',
            content: `ğŸ“š **${typeName}** ã‚’é–‹å§‹ã—ã¾ã™

ğŸ“‹ **è©¦é¨“ãƒ«ãƒ¼ãƒ«**
â€¢ ${maxThemes}ã¤ã®ãƒ†ãƒ¼ãƒã«ã¤ã„ã¦å‡ºé¡Œ
â€¢ å„å•é¡Œã¯10ç‚¹æº€ç‚¹ã§æ¡ç‚¹
â€¢ 6ç‚¹ä»¥ä¸Šã§æ¬¡ã®å•é¡Œã¸
â€¢ 5ç‚¹ä»¥ä¸‹ã§è£œè¶³è³ªå•ã®ãƒãƒ£ãƒ³ã‚¹

ğŸ“¦ **æŒã¡å¸°ã‚Šãƒ«ãƒ¼ãƒ«**
â€¢ ã€ŒæŒã¡å¸°ã‚Šã€ã¯2å›ã¾ã§ä½¿ç”¨å¯èƒ½
â€¢ 3å›ç›®ã§ä¸åˆæ ¼

âœ… **åˆæ ¼åŸºæº–**
â€¢ å›ç­”ã—ãŸãƒ†ãƒ¼ãƒã®60%ä»¥ä¸Š

ã€Œé–‹å§‹ã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`
          }]);
        }, 100);
      };

      const startReviewExam = () => {
        if (reviewItems.length === 0) return;
        setAppMode('reviewExam');
        setCurrentReviewIndex(0);
        setMessages([]);
        setGameState('question');
        
        const item = reviewItems[0];
        setTimeout(() => {
          setMessages([{
            role: 'examiner',
            content: `ğŸ“š **å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰** (${reviewItems.length}å•)

**ã€${item.themeName} - ${item.level}ã€‘**
${item.question}

ğŸ’¡ å‰å›ï¼š${item.score}ç‚¹`
          }]);
        }, 100);
      };

      const handleTakeHome = () => {
        const currentThemes = getThemes();
        if (takeHomeCount >= MAX_TAKE_HOME) {
          setGameState('result');
          addMessage('user', 'æŒã¡å¸°ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚');
          setTimeout(() => {
            const question = getCurrentQuestion();
            addMessage('examiner', `ğŸ“¦ **æŒã¡å¸°ã‚Šï¼ˆ3å›ç›®ï¼‰- ä¸åˆæ ¼**

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question?.modelAnswer || ''}

ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸`);
          }, 500);
          return;
        }

        const question = getCurrentQuestion();
        setTakeHomeCount(prev => prev + 1);
        setTakeHomeThemes(prev => [...prev, currentThemeIndex]);
        addMessage('user', 'æŒã¡å¸°ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚');
        
        setTimeout(() => {
          addMessage('examiner', `ğŸ“¦ **æŒã¡å¸°ã‚Šï¼ˆ${takeHomeCount + 1}/${MAX_TAKE_HOME}å›ï¼‰**

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question?.modelAnswer}`);
          setTimeout(() => handleThemeComplete(true), 1500);
        }, 500);
      };

      const handleThemeComplete = (isTakeHome = false) => {
        const currentThemes = getThemes();
        if (!isTakeHome) setCompletedThemes(prev => [...prev, currentThemeIndex]);
        const maxThemes = Math.min(5, currentThemes.length);
        
        if (usedThemes.length >= maxThemes) {
          setGameState('result');
          const validScores = scores.filter(s => {
            const themeIdx = currentThemes.findIndex(t => t.name === s.theme);
            return !takeHomeThemes.includes(themeIdx);
          });
          const answeredThemeCount = maxThemes - takeHomeThemes.length - (isTakeHome ? 1 : 0);
          const maxPossibleScore = validScores.length > 0 ? validScores.length * 10 : 1;
          const actualScore = validScores.reduce((acc, s) => acc + s.score, 0);
          const percentage = Math.round((actualScore / maxPossibleScore) * 100);
          const passed = percentage >= 60;
          
          addMessage('examiner', `ğŸ¯ **è©¦é¨“çµ‚äº†**

ğŸ“Š **çµæœ**
å›ç­”ï¼š${answeredThemeCount}ãƒ†ãƒ¼ãƒ / æŒã¡å¸°ã‚Šï¼š${takeHomeThemes.length + (isTakeHome ? 1 : 0)}
å¾—ç‚¹ï¼š${actualScore}ç‚¹ï¼ˆ${percentage}%ï¼‰

**åˆ¤å®šï¼š${passed ? 'ğŸ‰ åˆæ ¼' : 'ğŸ“š ä¸åˆæ ¼'}**

ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸`);
        } else {
          setGameState('question');
          const theme = selectNextTheme();
          if (theme) {
            const q = theme.questions[0];
            addMessage('examiner', `ğŸ“š **ãƒ†ãƒ¼ãƒ ${usedThemes.length}/${maxThemes}ï¼š${theme.name}**

ã€${q.level}å•é¡Œã€‘${q.question}`);
          }
        }
      };

      const handleSend = async () => {
        const currentThemes = getThemes();
        if (!inputValue.trim() || isLoading) return;
        const userInput = inputValue.trim();
        setInputValue('');
        addMessage('user', userInput);
        setIsLoading(true);

        try {
          if (userInput.includes('ãƒ¡ãƒ‹ãƒ¥ãƒ¼')) {
            setAppMode('menu');
            setIsLoading(false);
            return;
          }

          // å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰
          if (appMode === 'reviewExam') {
            if (gameState === 'confirmDelete') {
              if (userInput === 'å‰Šé™¤') {
                removeFromReview(reviewItems[currentReviewIndex].id);
                addMessage('examiner', 'âœ… å‰Šé™¤ã—ã¾ã—ãŸã€‚');
              }
              const newItems = userInput === 'å‰Šé™¤' ? reviewItems.filter((_, i) => i !== currentReviewIndex) : reviewItems;
              if (newItems.length === 0 || currentReviewIndex >= newItems.length) {
                addMessage('examiner', 'ğŸ“š å¾©ç¿’å®Œäº†ï¼ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸');
                setGameState('result');
              } else {
                setGameState('question');
                const next = newItems[currentReviewIndex];
                addMessage('examiner', `**ã€${next.themeName} - ${next.level}ã€‘** (${currentReviewIndex + 1}/${newItems.length})
${next.question}
ğŸ’¡ å‰å›ï¼š${next.score}ç‚¹`);
              }
              setIsLoading(false);
              return;
            }

            const item = reviewItems[currentReviewIndex];
            const result = await gradeAnswer(item.question, item.modelAnswer, item.keyPoints || [], userInput);
            const improved = result.score > item.score;
            
            addMessage('examiner', `**${result.score}ç‚¹** ${improved ? 'ğŸ“ˆ' : ''}
${result.feedback}

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${item.modelAnswer}`);

            setTimeout(() => {
              if (result.score >= 6) {
                addMessage('examiner', 'âœ¨ åˆæ ¼ï¼ã€Œå‰Šé™¤ã€ã§å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å‰Šé™¤ã€ä»–ã®å…¥åŠ›ã§æ¬¡ã¸');
                setGameState('confirmDelete');
              } else {
                if (currentReviewIndex < reviewItems.length - 1) {
                  setCurrentReviewIndex(prev => prev + 1);
                  const next = reviewItems[currentReviewIndex + 1];
                  addMessage('examiner', `**ã€${next.themeName} - ${next.level}ã€‘** (${currentReviewIndex + 2}/${reviewItems.length})
${next.question}
ğŸ’¡ å‰å›ï¼š${next.score}ç‚¹`);
                } else {
                  addMessage('examiner', 'ğŸ“š å¾©ç¿’å®Œäº†ï¼ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸');
                  setGameState('result');
                }
              }
            }, 1500);
            setIsLoading(false);
            return;
          }

          // é€šå¸¸è©¦é¨“
          if (gameState === 'start') {
            if (userInput.includes('é–‹å§‹')) {
              const theme = selectNextTheme();
              if (theme) {
                setGameState('question');
                const q = theme.questions[0];
                addMessage('examiner', `ğŸ“š **ãƒ†ãƒ¼ãƒ ${usedThemes.length}/${Math.min(5, currentThemes.length)}ï¼š${theme.name}**

ã€${q.level}å•é¡Œã€‘${q.question}`);
              }
            }
          } else if (gameState === 'question') {
            const question = getCurrentQuestion();
            if (!question) { setIsLoading(false); return; }
            
            const result = await gradeAnswer(question.question, question.modelAnswer, question.keyPoints, userInput);
            const newScore = { theme: currentThemes[currentThemeIndex].name, level: question.level, score: result.score };
            
            if (result.score <= 5) {
              addToReview({
                themeName: currentThemes[currentThemeIndex].name,
                level: question.level,
                question: question.question,
                modelAnswer: question.modelAnswer,
                keyPoints: question.keyPoints,
                score: result.score
              });
            }
            
            setScores(prev => [...prev, newScore]);

            let responseText = `**${result.score >= 6 ? 'âœ…' : 'âš ï¸'} ${result.score}ç‚¹**
${result.feedback}

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question.modelAnswer}`;

            if (result.score <= 5 && question.followUpQuestions && question.followUpQuestions.length > 0) {
              const followUpQ = question.followUpQuestions[Math.floor(Math.random() * question.followUpQuestions.length)];
              
              let followUpA = '';
              if (question.followUpQA) {
                const qa = question.followUpQA.find(qa => qa.question === followUpQ);
                if (qa) followUpA = qa.answer;
              }
              if (!followUpA && followUpAnswers[followUpQ]) {
                followUpA = followUpAnswers[followUpQ];
              }
              
              setCurrentFollowUp({ question: followUpQ, answer: followUpA });
              setWaitingForFollowUp(true);
              
              responseText += `

ğŸ“š å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ã«è¿½åŠ 

ğŸ’¡ **è£œè¶³è³ªå•**ï¼š${followUpQ}`;
              
              addMessage('examiner', responseText);
              setGameState('followUp');
            } else {
              addMessage('examiner', responseText);
              
              setTimeout(() => {
                if (currentQuestionIndex < currentThemes[currentThemeIndex].questions.length - 1) {
                  setCurrentQuestionIndex(prev => prev + 1);
                  const nextQ = currentThemes[currentThemeIndex].questions[currentQuestionIndex + 1];
                  addMessage('examiner', `ã€${nextQ.level}å•é¡Œã€‘${nextQ.question}`);
                } else {
                  handleThemeComplete();
                }
              }, 1500);
            }
          } else if (gameState === 'followUp') {
            const followUpResult = await gradeAnswer(
              currentFollowUp.question, 
              currentFollowUp.answer || 'ï¼ˆæ¨¡ç¯„è§£ç­”ãªã—ï¼‰', 
              [], 
              userInput
            );
            
            let followUpResponse = `**${followUpResult.score >= 6 ? 'âœ…' : 'âš ï¸'} ${followUpResult.score}ç‚¹**
${followUpResult.feedback}`;

            if (currentFollowUp.answer) {
              followUpResponse += `

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${currentFollowUp.answer}`;
            }

            addMessage('examiner', followUpResponse);
            setWaitingForFollowUp(false);
            setCurrentFollowUp(null);
            
            setTimeout(() => {
              if (currentQuestionIndex < currentThemes[currentThemeIndex].questions.length - 1) {
                setCurrentQuestionIndex(prev => prev + 1);
                const nextQ = currentThemes[currentThemeIndex].questions[currentQuestionIndex + 1];
                setGameState('question');
                addMessage('examiner', `ã€${nextQ.level}å•é¡Œã€‘${nextQ.question}`);
              } else {
                handleThemeComplete();
              }
            }, 1500);
          }
        } catch (err) {
          console.error(err);
          addMessage('examiner', 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
        } finally {
          setIsLoading(false);
        }
      };

      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
      if (appMode === 'loading') {
        return (
          <div className="min-h-screen bg-blue-50 flex items-center justify-center">
            <div className="text-center">
              <div className="text-4xl mb-4">ğŸ“š</div>
              <p className="text-blue-700">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
            </div>
          </div>
        );
      }

      // å•é¡Œè¿½åŠ ç”»é¢
      if (appMode === 'addQuestion') {
        return (
          <div className="min-h-screen bg-slate-50">
            <div className="bg-green-600 text-white p-4">
              <div className="max-w-4xl mx-auto flex justify-between items-center">
                <h1 className="text-xl font-bold">â• å•é¡Œè¿½åŠ </h1>
                <button onClick={() => setAppMode('menu')} className="bg-green-700 px-4 py-2 rounded-lg text-sm">
                  æˆ»ã‚‹
                </button>
              </div>
            </div>
            
            <div className="max-w-4xl mx-auto p-4">
              {/* ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ */}
              <div className="flex gap-2 mb-4">
                <button 
                  onClick={() => setAddMode('markdown')}
                  className={`px-4 py-2 rounded-lg font-medium ${addMode === 'markdown' ? 'bg-green-600 text-white' : 'bg-gray-200'}`}
                >
                  ğŸ“ Markdownå…¥åŠ›
                </button>
                <button 
                  onClick={() => setAddMode('json')}
                  className={`px-4 py-2 rounded-lg font-medium ${addMode === 'json' ? 'bg-green-600 text-white' : 'bg-gray-200'}`}
                >
                  ğŸ“‹ JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                </button>
              </div>
              
              {addMode === 'markdown' ? (
                <>
                  {/* Markdownå…¥åŠ› */}
                  <div className="bg-white rounded-xl p-4 shadow mb-4">
                    <div className="flex justify-between items-center mb-2">
                      <h3 className="font-bold text-gray-800">Markdownå…¥åŠ›</h3>
                      <button 
                        onClick={() => setMarkdownInput(SAMPLE_MARKDOWN)}
                        className="text-sm text-blue-600 hover:underline"
                      >
                        ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æŒ¿å…¥
                      </button>
                    </div>
                    <textarea
                      value={markdownInput}
                      onChange={(e) => setMarkdownInput(e.target.value)}
                      placeholder="## ãƒ†ãƒ¼ãƒXï¼šãƒ†ãƒ¼ãƒå&#10;&#10;### ã€äºˆæƒ³å•é¡Œ XXã€‘Q1ï¼ˆåŸºæœ¬å•é¡Œï¼‰&#10;**è³ªå•æ–‡...**"
                      className="w-full h-64 border rounded-lg p-3 text-sm markdown-input resize-y"
                    />
                    <div className="flex gap-2 mt-3">
                      <button 
                        onClick={handleParseMarkdown}
                        disabled={!markdownInput.trim()}
                        className="bg-blue-600 text-white px-4 py-2 rounded-lg disabled:bg-gray-300"
                      >
                        ğŸ” ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                      </button>
                      {parseResult && (
                        <button 
                          onClick={handleExportJson}
                          className="bg-gray-600 text-white px-4 py-2 rounded-lg"
                        >
                          ğŸ“‹ JSONã‚³ãƒ”ãƒ¼
                        </button>
                      )}
                    </div>
                  </div>
                  
                  {/* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */}
                  {parseError && (
                    <div className="bg-red-50 border border-red-200 rounded-xl p-4 mb-4 text-red-700">
                      âš ï¸ {parseError}
                    </div>
                  )}
                  
                  {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
                  {parseResult && (
                    <div className="bg-white rounded-xl p-4 shadow mb-4">
                      <h3 className="font-bold text-gray-800 mb-3">âœ… ãƒ‘ãƒ¼ã‚¹çµæœï¼ˆ{parseResult.length}ãƒ†ãƒ¼ãƒï¼‰</h3>
                      <div className="space-y-3 max-h-96 overflow-y-auto">
                        {parseResult.map((theme, idx) => (
                          <div key={idx} className="border rounded-lg p-3">
                            <div className="font-medium text-blue-700">{theme.name}</div>
                            <div className="text-sm text-gray-600 mt-1">
                              {theme.questions.length}å•
                              {theme.questions.map((q, qIdx) => (
                                <span key={qIdx} className="ml-2 bg-gray-100 px-2 py-0.5 rounded text-xs">
                                  {q.level}
                                </span>
                              ))}
                            </div>
                            <div className="text-xs text-gray-500 mt-2">
                              {theme.questions.map((q, qIdx) => (
                                <div key={qIdx} className="truncate">
                                  Q{qIdx+1}: {q.question.substring(0, 50)}...
                                </div>
                              ))}
                            </div>
                          </div>
                        ))}
                      </div>
                      <button 
                        onClick={handleSaveQuestions}
                        className="mt-4 w-full bg-green-600 text-white py-3 rounded-lg font-bold"
                      >
                        ğŸ’¾ ã‚«ã‚¹ã‚¿ãƒ å•é¡Œã¨ã—ã¦ä¿å­˜
                      </button>
                    </div>
                  )}
                </>
              ) : (
                <>
                  {/* JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ */}
                  <div className="bg-white rounded-xl p-4 shadow mb-4">
                    <h3 className="font-bold text-gray-800 mb-2">JSONå…¥åŠ›</h3>
                    <textarea
                      value={jsonInput}
                      onChange={(e) => setJsonInput(e.target.value)}
                      placeholder='[{"name": "ãƒ†ãƒ¼ãƒå", "questions": [{"level": "åŸºæœ¬", "question": "è³ªå•", "modelAnswer": "å›ç­”", "keyPoints": ["ãƒã‚¤ãƒ³ãƒˆ"]}]}]'
                      className="w-full h-64 border rounded-lg p-3 text-sm markdown-input resize-y"
                    />
                    <button 
                      onClick={handleImportJson}
                      disabled={!jsonInput.trim()}
                      className="mt-3 bg-green-600 text-white px-4 py-2 rounded-lg disabled:bg-gray-300"
                    >
                      ğŸ“¥ ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                    </button>
                  </div>
                  
                  {parseError && (
                    <div className="bg-red-50 border border-red-200 rounded-xl p-4 mb-4 text-red-700">
                      âš ï¸ {parseError}
                    </div>
                  )}
                </>
              )}
              
              {/* ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆèª¬æ˜ */}
              <div className="bg-blue-50 rounded-xl p-4 text-sm text-blue-800">
                <h4 className="font-bold mb-2">ğŸ“– Markdownãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</h4>
                <pre className="text-xs bg-white p-3 rounded overflow-x-auto">
{`## ãƒ†ãƒ¼ãƒXï¼šãƒ†ãƒ¼ãƒå

### ã€äºˆæƒ³å•é¡Œ XXã€‘Q1ï¼ˆåŸºæœ¬å•é¡Œï¼‰
**è³ªå•æ–‡ã‚’ã“ã“ã«**

### ã€æ¨¡ç¯„è§£ç­”ã€‘
æ¨¡ç¯„è§£ç­”ã‚’ã“ã“ã«

### ã€ã“ã®å•é¡Œã§è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆã€‘
- ãƒã‚¤ãƒ³ãƒˆ1
- ãƒã‚¤ãƒ³ãƒˆ2

### ã€æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•ã¨å›ç­”ã€‘

**Qï¼šè¿½åŠ è³ªå•**

**Aï¼š** å›ç­”`}
                </pre>
              </div>
            </div>
          </div>
        );
      }

      // ã‚«ã‚¹ã‚¿ãƒ å•é¡Œç®¡ç†ç”»é¢
      if (appMode === 'manageCustom') {
        return (
          <div className="min-h-screen bg-slate-50">
            <div className="bg-purple-600 text-white p-4">
              <div className="max-w-4xl mx-auto flex justify-between items-center">
                <h1 className="text-xl font-bold">âš™ï¸ ã‚«ã‚¹ã‚¿ãƒ å•é¡Œç®¡ç†</h1>
                <button onClick={() => setAppMode('menu')} className="bg-purple-700 px-4 py-2 rounded-lg text-sm">
                  æˆ»ã‚‹
                </button>
              </div>
            </div>
            
            <div className="max-w-4xl mx-auto p-4">
              {customThemes.length === 0 ? (
                <div className="bg-white rounded-xl p-8 shadow text-center">
                  <span className="text-5xl mb-4 block">ğŸ“­</span>
                  <p className="text-gray-600">ã‚«ã‚¹ã‚¿ãƒ å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“</p>
                  <button 
                    onClick={() => setAppMode('addQuestion')}
                    className="mt-4 bg-green-600 text-white px-6 py-2 rounded-lg"
                  >
                    â• å•é¡Œã‚’è¿½åŠ 
                  </button>
                </div>
              ) : (
                <>
                  <div className="flex justify-between mb-4">
                    <p className="text-gray-600">{customThemes.length}ãƒ†ãƒ¼ãƒ</p>
                    <button 
                      onClick={() => {
                        const json = JSON.stringify(customThemes, null, 2);
                        navigator.clipboard.writeText(json);
                        alert('å…¨ã‚«ã‚¹ã‚¿ãƒ å•é¡Œã‚’JSONã§ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
                      }}
                      className="text-blue-600 text-sm hover:underline"
                    >
                      ğŸ“‹ å…¨ã¦JSONã§ã‚³ãƒ”ãƒ¼
                    </button>
                  </div>
                  <div className="space-y-3">
                    {customThemes.map(theme => (
                      <div key={theme.id} className="bg-white rounded-xl p-4 shadow">
                        <div className="flex justify-between items-start">
                          <div>
                            <div className="font-bold text-purple-700">{theme.name}</div>
                            <div className="text-sm text-gray-600 mt-1">
                              {theme.questions.length}å•
                            </div>
                          </div>
                          <button 
                            onClick={() => handleDeleteCustomTheme(theme.id)}
                            className="text-red-500 hover:text-red-700"
                          >
                            ğŸ—‘ï¸ å‰Šé™¤
                          </button>
                        </div>
                        <div className="mt-2 text-xs text-gray-500">
                          {theme.questions.map((q, idx) => (
                            <div key={idx} className="truncate">
                              [{q.level}] {q.question.substring(0, 40)}...
                            </div>
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼
      if (appMode === 'menu') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
            <div className="max-w-2xl mx-auto pt-4">
              <div className="text-center mb-5">
                <h1 className="text-2xl font-bold text-blue-900 mb-1">åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ</h1>
                <p className="text-lg text-blue-700">å£è¿°è©¦é¨“å¯¾ç­–ã‚·ã‚¹ãƒ†ãƒ </p>
              </div>
              
              {loadError && (
                <div className="bg-yellow-50 border border-yellow-200 rounded-xl p-3 mb-4 text-sm text-yellow-800">
                  âš ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«ä¸€éƒ¨å¤±æ•—ã—ã¾ã—ãŸã€‚
                </div>
              )}
              
              <div className="space-y-3">
                {/* æœ¬ç·¨ */}
                <button 
                  onClick={() => startExam('main')} 
                  disabled={mainThemes.length === 0}
                  className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-2xl p-4 text-left shadow-lg"
                >
                  <div className="flex items-center gap-3">
                    <span className="text-2xl">ğŸ“</span>
                    <div className="flex-1">
                      <h2 className="text-lg font-bold">æœ¬ç·¨ï¼ˆè©³ç´°è§£èª¬ä»˜ãï¼‰</h2>
                      <p className="text-blue-200 text-xs">åŸºæœ¬â†’è©³ç´°â†’å¿œç”¨ã®3æ®µéšæ§‹æˆ</p>
                    </div>
                    <span className="bg-blue-500 px-3 py-1 rounded-full text-sm">
                      {mainThemes.length}
                    </span>
                  </div>
                </button>
                
                {/* è¿½åŠ å•é¡Œç·¨ */}
                <button 
                  onClick={() => startExam('extra')} 
                  disabled={extraThemes.length === 0}
                  className="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 text-white rounded-2xl p-4 text-left shadow-lg"
                >
                  <div className="flex items-center gap-3">
                    <span className="text-2xl">ğŸ“‹</span>
                    <div className="flex-1">
                      <h2 className="text-lg font-bold">è¿½åŠ å•é¡Œç·¨</h2>
                      <p className="text-indigo-200 text-xs">è£œè¶³çš„ãªå•é¡Œã§çŸ¥è­˜ã‚’è£œå¼·</p>
                    </div>
                    <span className="bg-indigo-500 px-3 py-1 rounded-full text-sm">
                      {extraThemes.length}
                    </span>
                  </div>
                </button>
                
                {/* ã‚«ã‚¹ã‚¿ãƒ å•é¡Œ */}
                <button 
                  onClick={() => startExam('custom')} 
                  disabled={customThemes.length === 0}
                  className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white rounded-2xl p-4 text-left shadow-lg"
                >
                  <div className="flex items-center gap-3">
                    <span className="text-2xl">âœ¨</span>
                    <div className="flex-1">
                      <h2 className="text-lg font-bold">ã‚«ã‚¹ã‚¿ãƒ å•é¡Œ</h2>
                      <p className="text-purple-200 text-xs">è‡ªåˆ†ã§è¿½åŠ ã—ãŸå•é¡Œ</p>
                    </div>
                    <span className="bg-purple-500 px-3 py-1 rounded-full text-sm">
                      {customThemes.length}
                    </span>
                  </div>
                </button>
                
                {/* å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ */}
                <button 
                  onClick={() => setAppMode('review')} 
                  className="w-full bg-amber-500 hover:bg-amber-600 text-white rounded-2xl p-4 text-left shadow-lg relative"
                >
                  <div className="flex items-center gap-3">
                    <span className="text-2xl">ğŸ“š</span>
                    <div>
                      <h2 className="text-lg font-bold">å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€</h2>
                      <p className="text-amber-100 text-xs">5ç‚¹ä»¥ä¸‹ã®å•é¡Œã‚’å¾©ç¿’</p>
                    </div>
                  </div>
                  {reviewItems.length > 0 && (
                    <span className="absolute top-3 right-3 bg-red-500 text-white text-sm font-bold px-3 py-1 rounded-full">
                      {reviewItems.length}
                    </span>
                  )}
                </button>
              </div>
              
              {/* å•é¡Œè¿½åŠ ãƒ»ç®¡ç† */}
              <div className="mt-4 flex gap-2">
                <button 
                  onClick={() => { setAppMode('addQuestion'); setParseResult(null); setParseError(null); }}
                  className="flex-1 bg-green-600 hover:bg-green-700 text-white rounded-xl p-3 shadow"
                >
                  <span className="text-lg">â•</span>
                  <span className="ml-2 font-medium">å•é¡Œè¿½åŠ </span>
                </button>
                <button 
                  onClick={() => setAppMode('manageCustom')}
                  className="flex-1 bg-gray-600 hover:bg-gray-700 text-white rounded-xl p-3 shadow"
                >
                  <span className="text-lg">âš™ï¸</span>
                  <span className="ml-2 font-medium">ã‚«ã‚¹ã‚¿ãƒ ç®¡ç†</span>
                </button>
              </div>
              
              {/* çµ±è¨ˆ */}
              <div className="mt-4 grid grid-cols-4 gap-2">
                <div className="bg-white rounded-xl p-2 shadow text-center">
                  <div className="text-xl font-bold text-blue-600">{mainThemes.length}</div>
                  <div className="text-gray-500 text-xs">æœ¬ç·¨</div>
                </div>
                <div className="bg-white rounded-xl p-2 shadow text-center">
                  <div className="text-xl font-bold text-indigo-600">{extraThemes.length}</div>
                  <div className="text-gray-500 text-xs">è¿½åŠ </div>
                </div>
                <div className="bg-white rounded-xl p-2 shadow text-center">
                  <div className="text-xl font-bold text-purple-600">{customThemes.length}</div>
                  <div className="text-gray-500 text-xs">ã‚«ã‚¹ã‚¿ãƒ </div>
                </div>
                <div className="bg-white rounded-xl p-2 shadow text-center">
                  <div className="text-xl font-bold text-amber-600">{reviewItems.length}</div>
                  <div className="text-gray-500 text-xs">å¾©ç¿’</div>
                </div>
              </div>
              
              {/* APIã‚­ãƒ¼è¨­å®š */}
              <div className="mt-4 bg-white rounded-xl p-3 shadow">
                <div className="flex justify-between items-center">
                  <h3 className="font-bold text-gray-800 text-sm">ğŸ”‘ APIã‚­ãƒ¼</h3>
                  <button 
                    onClick={() => setShowApiKeyInput(!showApiKeyInput)}
                    className="text-blue-600 text-sm hover:underline"
                  >
                    {showApiKeyInput ? 'é–‰ã˜ã‚‹' : (apiKey ? 'å¤‰æ›´' : 'è¨­å®š')}
                  </button>
                </div>
                
                {apiKey && !showApiKeyInput && (
                  <p className="text-green-600 text-xs mt-1">âœ… è¨­å®šæ¸ˆã¿</p>
                )}
                
                {!apiKey && !showApiKeyInput && (
                  <p className="text-amber-600 text-xs mt-1">âš ï¸ AIæ¡ç‚¹ã«ã¯APIã‚­ãƒ¼ãŒå¿…è¦</p>
                )}
                
                {showApiKeyInput && (
                  <div className="mt-2">
                    <input
                      type="password"
                      placeholder="sk-ant-api03-..."
                      defaultValue={apiKey}
                      className="w-full border rounded-lg px-3 py-2 text-sm"
                      onBlur={(e) => saveApiKey(e.target.value)}
                    />
                    <p className="text-xs text-gray-500 mt-1">
                      <a href="https://console.anthropic.com/settings/keys" target="_blank" className="text-blue-600 hover:underline">
                        Anthropic Console
                      </a> ã§å–å¾—
                    </p>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }

      // å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€
      if (appMode === 'review') {
        return (
          <div className="min-h-screen bg-slate-50">
            <div className="bg-amber-500 text-white p-4">
              <div className="max-w-4xl mx-auto flex justify-between items-center">
                <h1 className="text-xl font-bold">ğŸ“š å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€</h1>
                <button onClick={() => setAppMode('menu')} className="bg-amber-600 px-4 py-2 rounded-lg text-sm">
                  æˆ»ã‚‹
                </button>
              </div>
            </div>
            <div className="max-w-4xl mx-auto p-4">
              {reviewItems.length === 0 ? (
                <div className="bg-white rounded-xl p-8 shadow text-center">
                  <span className="text-5xl mb-4 block">ğŸ‰</span>
                  <p className="text-gray-600">å¾©ç¿’ã™ã‚‹å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“</p>
                </div>
              ) : (
                <>
                  <div className="flex justify-between mb-4">
                    <p className="text-gray-600">{reviewItems.length}å•</p>
                    <button onClick={startReviewExam} className="bg-amber-500 text-white px-4 py-2 rounded-lg">
                      ğŸ¯ å¾©ç¿’é–‹å§‹
                    </button>
                  </div>
                  <div className="space-y-3">
                    {reviewItems.map(item => (
                      <div key={item.id} className="bg-white rounded-xl p-4 shadow">
                        <div className="flex justify-between">
                          <div>
                            <span className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded mr-2">{item.level}</span>
                            <span className="font-medium">{item.themeName}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <span className="text-red-500 font-bold">{item.score}ç‚¹</span>
                            <button onClick={() => removeFromReview(item.id)} className="text-gray-400 hover:text-red-500">âœ•</button>
                          </div>
                        </div>
                        <p className="text-gray-700 text-sm mt-2">{item.question.substring(0, 80)}...</p>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      // è©¦é¨“ç”»é¢
      const currentThemes = getThemes();
      const maxThemes = Math.min(5, currentThemes.length);
      const canTakeHome = appMode === 'exam' && (gameState === 'question' || gameState === 'followUp');
      const isReviewMode = appMode === 'reviewExam';
      const headerColor = isReviewMode ? 'bg-amber-500' : 
                         (examType === 'main' ? 'bg-blue-700' : 
                         (examType === 'extra' ? 'bg-indigo-700' : 'bg-purple-700'));
      
      return (
        <div className="flex flex-col h-screen bg-slate-50">
          <div className={`${headerColor} text-white p-4`}>
            <div className="max-w-4xl mx-auto flex justify-between items-center">
              <h1 className="font-bold">
                {isReviewMode ? 'ğŸ“š å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰' : 
                 (examType === 'main' ? 'ğŸ“ æœ¬ç·¨' : 
                 (examType === 'extra' ? 'ğŸ“‹ è¿½åŠ å•é¡Œç·¨' : 'âœ¨ ã‚«ã‚¹ã‚¿ãƒ å•é¡Œ'))}
              </h1>
              {!isReviewMode && (
                <div className="text-sm">
                  ãƒ†ãƒ¼ãƒ {usedThemes.length}/{maxThemes} | æŒã¡å¸°ã‚Šæ®‹ã‚Š {MAX_TAKE_HOME - takeHomeCount}
                </div>
              )}
            </div>
          </div>

          <div className="flex-1 overflow-y-auto p-4">
            <div className="max-w-4xl mx-auto space-y-4">
              {messages.map((msg, idx) => (
                <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div className={`max-w-3xl rounded-2xl px-4 py-3 ${
                    msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white border shadow-sm'
                  }`}>
                    <div className="whitespace-pre-wrap text-sm">
                      {msg.content.split(/(\*\*[^*]+\*\*)/).map((part, i) => 
                        part.startsWith('**') && part.endsWith('**') 
                          ? <strong key={i}>{part.slice(2, -2)}</strong> 
                          : part
                      )}
                    </div>
                  </div>
                </div>
              ))}
              {isLoading && (
                <div className="flex justify-start">
                  <div className="bg-white border rounded-2xl px-4 py-3 shadow-sm">
                    <span className="text-gray-500 text-sm">æ¡ç‚¹ä¸­...</span>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>
          </div>

          <div className="bg-white border-t p-4">
            <div className="max-w-4xl mx-auto flex gap-2">
              {canTakeHome && takeHomeCount < MAX_TAKE_HOME && (
                <button onClick={handleTakeHome} disabled={isLoading}
                  className="px-4 py-3 rounded-xl font-semibold bg-amber-100 text-amber-700 border-2 border-amber-300">
                  ğŸ“¦ æŒã¡å¸°ã‚Š
                </button>
              )}
              <textarea
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }}
                placeholder="å›ç­”ã‚’å…¥åŠ›..."
                className="flex-1 border rounded-xl px-4 py-3 resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                rows={2}
                disabled={isLoading}
              />
              <button onClick={handleSend} disabled={isLoading || !inputValue.trim()}
                className="bg-blue-600 text-white px-6 py-3 rounded-xl font-semibold hover:bg-blue-700 disabled:bg-gray-300">
                é€ä¿¡
              </button>
            </div>
            <p className="text-xs text-gray-500 mt-2 text-center">ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã¨å…¥åŠ›ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸</p>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
